# AIPARA C++ 插件迁移计划

本文档分阶段描述了将 Lua 实现的 AIPARA 扩展迁移到 `plugins/aipara/` 下的原生 C++ 插件所需的工作。每一步都以 AI 辅助开发流程为前提，提供清晰的里程碑与集成任务。

## 阶段 0 – 调研与工程准备
- 审核现有 Lua 模块，记录行为、入口和共享状态，为每个插件撰写精简规格（输入、输出、副作用）。
- 清点当前 C++ 插件的挂载点、Schema 引用与构建目标，确认 `plugins/aipara` 已在顶层 CMake 中正确注册，支持开发环境加载。
- 制定统一的编码规范（命名、日志、线程、所有权），保证迁移后的实现风格一致、便于维护。

## 阶段 1 – 公共基础设施
- **日志模块：** 在 `plugins/aipara/src/common/` 内设计可复用的 `Logger` 辅助类，覆盖 Lua logger 的能力（日志级别、文件轮转、可选控制台输出），与 Rime 的 `Log` 设施对接，并暴露轻量宏供模块调用。
- **文本处理：** 将 `text_formatting.lua` 迁移为 C++ 工具命名空间（裁剪、分割、模板辅助等），参考 Lua 行为编写单元测试确保一致性。
- **Socket 同步桥：** 评估 `tcp_socket_sync.lua` 是否仍需保留；若需要，封装为 RAII 风格的 C++ POSIX Socket 类，支持超时控制与最小依赖，并清晰注明线程模型。
- 实现共享配置访问器，封装多处重复的 Schema 读取逻辑（如 `ai_assistant/...`），提供缓存与失效机制。

## 阶段 2 – 核心 Processor（输入阶段）
1. **smart_cursor_processor**
   - 将 Lua 逻辑复现为 `Processor` 子类，关注光标移动、选区处理与 Schema 标志位。
   - 为异常按键序列添加防御式保护，并通过调试开关输出详细日志。
2. **cloud_input_processor**
   - 实现共享配置与状态更新的生命周期管理（Lua 中此模块扮演协调角色）。
   - 确保与 translator/filter 同步时的线程安全，并在 Schema 更新时触发配置刷新。
3. 构建集成测试或脚本场景，模拟关键按键事件，验证 Processor 链路行为正确。

## 阶段 3 – Segmentor 与 Translator
1. **ai_assistant_segmentor**
   - 复刻分词流程，包括触发词解析、回复路由以及属性存储。
   - 复用共享工具处理配置缓存和日志，覆盖长输入与边界触发场景。
2. **rawenglish_segment**
   - 实现仅处理英文的分段逻辑，谨慎处理 ASCII 与混合输入。
3. **ai_assistant_translator**
   - 迁移消息生成及与云服务/缓存交互逻辑，如涉及网络调用则复用 Socket 工具或规划异步扩展。
4. **rawenglish_translator**
   - 完成英文直通翻译、候选回退以及标点兼容逻辑。
5. 编写针对典型输入的基准测试，通过比较 Lua 与 C++ 产生的候选项，验证行为一致。

## 阶段 4 – Filter 与后处理
1. **aux_code_filter_v3**
   - 转换过滤逻辑，确保候选修改保持 Unicode 安全与标签完整。
2. **cloud_ai_filter_v2**
   - 实现 AI 响应注入，遵守限流与 Schema 配置，复用网络工具。
3. **punct_eng_chinese_filter**
   - 迁移标点转换与中英文切换，记录本地化边界情况。
4. 为每个过滤器准备冒烟测试，使用模拟候选流断言输出，依托 Rime 测试框架或自建 mock。

## 阶段 5 – 日志与诊断
- 将所有模块的 Lua 日志调用替换为新的 C++ logger，确保轮转或截断行为与 Lua 相同。
- 若确有需要再迁移 `debug_utils.lua`，否则提供编译期开关用于开发期追踪。
- 编写文档说明如何通过 Schema 配置或环境变量开启详尽跟踪。

## 阶段 6 – Schema 与发布集成
- 更新相关 `.schema.yaml` 配置，引用新的 C++ 组件，同时保留（可注释）Lua 回退方案以便测试期快速切换。
- 编写迁移说明，覆盖配置开关、构建步骤与常见问题排查。
- 协调 CI 或打包脚本，确保新插件默认编译并随发行版分发。

## 验证与上线清单
- [ ] 全部迁移模块编译无警告，并通过格式化/静态检查。
- [ ] 依据核心流程（AI 对话触发、英文直通、标点过滤）完成功能对比测试。
- [ ] 在长时间运行中验证日志与配置热加载行为。
- [ ] 确认云服务不可用时的降级策略可用、无崩溃。
- [ ] 文档与 Schema 更新已在预发布环境验证。

## 后续规划/可选目标
- 衡量 C++ 与 Lua 的性能差异，量化收益。
- 研究异步网络方案（如 libuv 或 `std::async`），在不阻塞主线程的情况下处理 AI 调用。
- 增补错误场景（配置缺失、触发词异常）的单元测试。
- 探索复用现有 Rime 云端组件，减少重复代码。
